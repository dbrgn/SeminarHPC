\chapter{Knacken von MD5 mit OpenCL}
\rhead{Knacken von MD5 mit OpenCL}
\begin{refsection}

\chapterauthor{Danilo Bargen, Lukas Murer}

\section{Einleitung}

%- Was ist ein Hash-Algorithmus?
%- Was ist MD5?
%- Was ist Brute Force Cracking?
%- "Uberlegungen zum Keyspace
%- Zielsetzung

\subsection{Hashfunktionen}

Hashfunktionen (zu Deutsch \textit{Streuwertfunktionen}) sind in der Informatik
allgegenw"artig. Die Aufgabe einer Hashfunktion ist es, eine beliebig grosse
Eingabemenge auf eine kleine Ausgabemenge mit fester L"ange abzubilden.
Anwendungsgebiete sind beispielsweise die Integrit"atspr"ufung von Daten
(Pr"ufsummen) oder das Verschleiern von Passw"ortern (Passwort-Hashes).

Mathematisch gesehen ist eine Abbildung $h: K \rightarrow S$ eine Hashfunktion,
wenn $|K| \geq |S|$ gilt. Dabei ist $K$ die Menge der Schl"ussel und $S$ die
Menge der m"oglichen Hashwerte.

Eine der einfachsten Hashfunktionen ist die Quersumme, bei welcher die
Ziffernwerte einer Zahl summiert werden.
\[
	q(1337) = 1 + 3 + 3 + 7 = 14
\]
Weitere bekannte Hashfunktionen sind die Divisions-Rest-Methode
(Modulo-Arithmetik), CRC-Pr"ufsummen (Integrit"atspr"ufung) oder der Secure Hash
Algorithm (Kryptologie).

Die Anforderungen an eine ``gute'' Hashfunktion sind Abh"angig vom
Anwendungsbereich. Bei der ISBN-10 ist beispielsweise lediglich eine
Plausibilit"atspr"ufung in Form einer Pr"ufsumme n"otig. Bei Anwendungsf"allen
in der Kryptologie (zum Beispiel beim Hashen von Passw"ortern) sind jedoch viele
weitere Kriterien relevant. Nachfolgend werden einige davon vorgestellt.

\subsection{Eigenschaften von Hashfunktionen}

\subsubsection{Chaos}

Die Ausgabe einer chaotischen Hashfunktion sollte f"ur "ahnliche Eingabewerte
v"ollig unterschiedlich sein. Eine kleine "Anderung am Eingabewert sollte eine
grosse "Anderung im Ausgabewert zur Folge haben.

\subsubsection{Schwierige Umkehrbarkeit}

Eine schwierig umkehrbare Hashfunktion hat zum Ziel die Berechnung des
Funktionswertes m"oglichst zu vereinfachen, aber die Umkehrung dieses Ergebnisses
(berechnen des Ausgangswertes aus der Abbildung) m"oglichst zu erschweren. Anders
gesagt, es soll praktisch nicht m"oglich sein, zu einem gegebenen Hashwert $x$
eine Nachricht $m$ zu finden, f"ur welche $h(m) = x$ gilt.  Funktionen welche
diese Eigenschaft erf"ullen werden auch Einwegfunktionen genannt.

\subsubsection{Surjektivit"at}

Bei einer surjektiven Hashfunktion ist kein Ausgabewert unm"oglich, jeder kann
tats"achlich vorkommen.

\subsubsection{Kollisionsresistenz}
\label{crypto:kollisionsresistenz}

Eine Kollisionsresistente Hashfunktion sollte es erschweren, zwei Eingabewerte
zu finden die den selben Ausgabewert ergeben. Daf"ur sollten die Ausgabewerte
m"oglichst gleichverteilt auftreten.

In der Kryptologie wird zwischen schwacher und starker Kollisionsresistenz
unterschieden\cite{crypto:stephan2011kryptographie}:

\begin{itemize}
		\item Schwache Kollisionsresistenz heisst, dass es praktisch nicht m"oglich
			ist, zu einer gegebenen Nachricht $m_0$ eine zweite Nachricht $m_1$ zu finden, f"ur
			welche $h(m_0) = h(m_1)$ gilt.
		\item Starke Kollisionsresistenz heisst, dass es praktisch nicht m"oglich
			ist, zwei Nachrichten $m_0$ und $m_1$ zu finden, f"ur welche $h(m_0) =
			h(m_1)$ gilt.
\end{itemize}

\subsubsection{Effizienz}

Je nach Anwendungsfall m"ochte man effiziente oder ineffiziente Berechnungen
eines Hashwertes erzielen. W"ahrend ersteres logisch erscheint -- man m"ochte
den Algorithmus in Hard- und Software m"oglichst einfach und schnell
implementieren k"onnen -- ist letzteres auf den ersten Blick ein merkw"Urdiges
Ziel. Die Eigenschaft ist jedoch vor allem f"ur Passwort-Hash-Funktionen
relevant. Um zu verhindern dass ein Angreifer m"oglichst schnell alle m"oglichen
Passw"orter vorberechnet, m"ochte man eine Funktion welche aufw"andig und
ressourcenintensiv zu berechnen ist.

\subsection{MD5}

Der MD5 Algorithmus (Message-Digest Algorithm 5) wurde im Jahr 1991 vom
Kryptologen Ronald L. Rivest entwickelt. MD5 erzeugt zu einer beliebigen
Nachricht einen 128-Bit Hashwert.

Unter Unix-basierten Betriebssystemen kann man MD5-Werte ganz einfach auf der
Kommandozeile berechnen:

\begin{verbatim}
$ echo -n "Mathematisches Seminar" | md5sum 
47b2d986d0ae09d6504b9696e9406ca4
\end{verbatim}

Man sieht also, dass der Eingabewert ``Mathematisches Seminar'' auf den
Ausgabewert \texttt{47b2\-d986\-d0ae\-09d6\-504b\-9696\-e940\-6ca4} (in
hexadezimaler Notation) abgebildet wird. Wenn man nun nur ein einzelnes
Zeichen im Eingabestring "andert, sieht die Ausgabe v"ollig anders aus
($\rightarrow$ Chaoseigenschaft):

\begin{verbatim}
$ echo -n "Mathematisches Saminar" | md5sum 
625a5fb1280f153aa06709d70b38dfb8
\end{verbatim}

MD5 war (und ist) weit verbreitet und wurde in der Vergangenheit neben der
Integrit"atspr"ufung auch h"aufig zum Verschleiern von Passw"ortern verwendet.
Wie dies funktioniert, l"asst sich einfach an einem Praxisbeispiel
demonstrieren:

\begin{enumerate}
		\item Ein Benutzer registriert sich mit Benutzername und Passwort auf einer
			Website. Beide Werte werden an den Webserver "ubertragen.
		\item Der Server berechnet den Hashwert des Passwortes. Das Passwort wird
			verworfen, nur der Hashwert wird gespeichert.
		\item Der User m"ochte sich zu einem sp"ateren Zeitpunkt wieder einloggen.
			Daf"ur "ubermittelt er erneut das Passwort an den Server.
		\item Der Server berechnet erneut den Hashwert des Passwortes und
			vergleicht diesen mit dem zuvor gespeicherten Wert. Stimmen die beiden
			Werte "uberein, wird dem Benutzer Zugang zu den gesch"utzten Inhalten
			gew"ahrt.
\end{enumerate}

An diesem Beispiel erkennt man auch sehr gut, wie wichtig die Einwegeigenschaft
und die Kollisionsresistenz f"ur kryptologische Hashfunktionen ist. Sollte
n"amlich ein Passwort-Hash an die "Offentlichkeit gelangen (beispielsweise durch
ein Datenleck, wie sie in den letzten Jahren -- zuletzt bei Adobe -- immer
wieder geschehen sind), sollte es f"ur einen Angreifer mit praktischem Aufwand
nicht m"oglich sein, ausgehend vom Hashwert das urspr"ungliche Passwort zu
errechnen. Ebensowenig sollte es m"oglich sein, ein anderes Passwort zu finden
welches den selben Hashwert ergibt. In beiden F"allen w"are das Benutzerpasswort
dadurch kompromittiert.

MD5 gilt inzwischen als unsicher, weil erfolgreiche Angriffe auf die
Kollisionsresistenz des Algorithmus gefunden wurden. Bereits im Jahr 2006 gelang
es Forschern, MD5-Kollisionen auf einem Pentium 4 Rechner im Durchschnitt
innerhalb einer Minute zu finden\cite{crypto:stevens2006fast}. Inzwischen sind
Kollisionen auf markt"ublicher Hardware innerhalb weniger Sekunden berechenbar.
Der MD5-Algorithmus ist also h"ochstens schwach kollisionsresistent
(\ref{crypto:kollisionsresistenz}) und sollte f"ur kryptologische Anwendungen
nicht mehr eingesetzt werden.

\subsection{Brute-Force Angriff auf MD5}

W"ahrend Kollisionen f"ur frei gew"ahlte Eingabewerte wie im letzten Abschnitt
beschrieben heute problemlos berechenbar sind, ist bisher noch kein praktischer
Preimage-Angriff auf MD5 bekannt. Ein Preimage-Angriff bedeutet, dass der
Ausgabewert nicht frei gew"ahlt werden kann, sondern festgelegt ist (ein Angriff
auf die schwache Kollisionsresistenz). Wenn man nun einen Passwort-Hash
zur"uckrechnen will, ist bei einer "uberschaubaren Eingabemenge ein Brute-Force
Angriff die einfachste M"oglichkeit.

Bei einem Brute Force Angriff wird f"ur jeden Wert einer bestimmten
Eingabemenge der Hash\-wert berechnet und mit dem Zielwert verglichen. In
Pseudocode:

\begin{verbatim}
target = "47b2d986d0ae09d6504b9696e9406ca4"
for word in keyspace:
  if md5(word) == target:
    print(word)
    break
\end{verbatim}

Die Eingabemenge nennt man auch ``Keyspace''. Will man beispielsweise f"ur alle
Passw"orter bestehend aus den Klein- und Grossbuchstaben a-z / A-Z sowie den
Zahlen 0-9 mit einer L"ange von bis zu 6 Zeichen die Hashes berechnen, ergibt
dies "uber 57 Milliarden M"oglichkeiten.
\[
	\sum_{i=1}^{6} \left(26 + 26 + 10\right)^i = 57'731'386'986
\]
Hier sieht man auch schon die Schwierigkeit an der Sache, denn der Keyspace
w"achst exponentiell. Bei Erh"ohung der Maximall"ange auf 8 Zeichen sind wir schon
in der Gr"ossenordnung von ~200 Billionen.
\[
	\sum_{i=1}^{8} \left(26 + 26 + 10\right)^i = 221'919'451'578'090
\]
Im Rahmen dieser Arbeit beschr"ankten wir daher sowohl die Anzahl der m"oglichen
Zeichen wie auch die maximale L"ange der zu knackenden Passw"orter.

\subsection{Zielsetzung}

Unser Ziel im Rahmen dieser Arbeit war es, durch massiv parallele Berechnung von
MD5-Hashwerten dasjenige Eingabewort zu finden, dessen MD5-Hashwert einem zuvor
festgelegten Hashwert entspricht. Der Keyspace besteht dabei aus den
Kleinbuchstaben a-z mit einer variablen L"ange von bis zu 6 Zeichen.

Konkret haben wir uns als Ziel gesetzt in m"oglichst kurzer Zeit den MD5-Hash
des Wortes ``monkey'' (Platz 6 auf der Liste der am h"aufigsten verwendeten
Passw"orter 2012 \cite{crypto:splash2012}) zu knacken.

\begin{verbatim}
$ echo -n "monkey" | md5sum
d0763edaa9d9bd2a9516280e9044d885
\end{verbatim}

\section{Umsetzung mit OpenCL}

Wenn man einen MD5-Hash brute-forcen will, ben"otigt man eine massive Anzahl
komplett unabh"angiger paralleler Tasks. Die MD5-Berechnung selbst ist nicht
unabh"angig und wird deshalb nicht parallelisiert, aber mehrere MD5-Berechnungen
k"onnen nebeneinander ausgef"uhrt werden und ben"otigen keinerlei
Interprozess-Kommunikation. OpenCL ist hierf"ur also bestens geeignet.

\section{Probleme mit grossen Problemen}

\subsection{Einf"uhrung}

Auch wenn OpenCL ausdr"ucklich daf"ur entwickelt wurde, mit riesigen Clustern
von heterogenen Recheneinheiten sehr umfangreiche Probleme zu l"osen, so st"osst
man doch irgendwann an die Grenzen der Hardware oder der Implementierung.  Denn
jeder Kernel der ausgef"uhrt wird, ben"otigt Speicherplatz (Gr"osse des zur
Verf"ugung stehenden Speichers, Hardware) und muss irgendwie verwaltet werden
(Anzahl der maximal verwaltbaren Work-Items und Work-Groups, Implementierung).
Zudem ist die Anzahl Dimensionen, die von einem Kernel verarbeitet werden kann,
begrenzt (Work-Item-Dimension, Hardware \& Implementierung). Deshalb folgen in
diesem Kapitel einige Betrachtungen dazu, wie man mit diesen Limitationen
umgehen kann.

% TODO: Im Kapitel "Brute-Force Angriff auf MD5" werden fast die selben
% Berechnungen (Kombinatorik) bereits gemacht. Ev kann man darauf verweisen,
% anstatt sie hier nochmals zu machen?
Angenommen wir verwenden nur den Zeichensatz [a-zA-Z0-9] sprich insgesamt 62 
unterschiedliche Zeichen, die beliebig kombiniert werden k"onnen. Die 
Kombinatorik sagt dazu, dass es also

\[
 N_{Komb} =  62^{n}
\]

m"ogliche Kombinationen gibt,  wobei \[n\] die Anzahl der Zeichen im Wort angibt. 
Das ergibt bei einer Stellenzahl von 8 Stellen, was so in etwa der gel"aufigen 
Mindestl"ange eines Passworts entspricht 

\[ 
 N_{Komb} = 62^{8} = 2.183 * 10^12 
\] 

Kombinationen. Demgegen"ber stehen aber auf einem System mit einem Intel i5-3320M 
Prozessor und 8GB RAM und in einer OpenCL Workgroup maximal

\[
 N_{max} = N_{Workitems}^{wi_dim} = 8193^{3} = 5.50 * 10^11
\]

verwaltbare ``Problem-St"ucke'' entgegen. Trotzdem l"asst zum Beispiel die OpenCL
Implementierung von Intel auch eine gr"ossere Anzahl WorkItems problemlos zu, 
wohingegen sich die Nvidia Implementation mit einer ``Out-of-resources''-Meldung 
beendet.

Genau um diese Grenzen soll es in diesem Abschnitt gehen. Es soll aber in keinster
Weise ersch"opfend die Grenzen von OpenCL oder alle Spezifikas der 
Implementierungen eingegangen werden, sondern vielmehr f"ur das Thema sensibilisiert 
und m"ogliche Ans"atze f"ur den Umgang mit grossen Problemen in OpenCL aufgezeigt
werden, was hoffentlich dazu f"uhren wird, dass der Leser/die Leserin ein Gesp"ur 
f"ur eigene, auf die spezifische Hardware und Implementierung zugeschnittene 
Ans"atze entwickeln kann.


\subsection{Grenzen von OpenCL}

% TODO: Ich w체rde auf Erweiterungen gar nicht erst eingehen. Sie sind f체r uns ja
% nicht sonderlich relevant.
OpenCL wurde entwickelt um trotz einem m"glichst Plattform"ubergreifenden Ansatz 
sehr flexibel auf die Spezifika der jeweiligen Hardware reagieren zu k"onnen, was
auch das ebenfalls in OpenGL vorhandene Extension-System beinhaltet. Vor allem f"ur
% TODO: Hier ebenfalls, ich w체rde OpenGL gar nicht erst erw채hnen, sondern ganz
% auf OpenCL fokussieren.
Einsteiger in die OpenCL/OpenGL-Welt (hier sei erw"ahnt, dass hinter beiden 
Technologien sehr "anhliche Grundkonzepte stehen) kann es dabei schwierig werden
sich im Dschungel der Hardwaredaten und M"oglichkeiten zurechtzufinden. Auf die 
wichtigsten Einstiegspunkte und die f"ur unsere Problemstellung relevanten Punkte
soll hier kurz eingegangen werden.


\subsubsection{Hardwaremerkmale abfragen}

Gerade weil OpenCL so unterschiedliche Typen Hardware unterst"utzt, von der ``normalen''
Desktop-CPU bis zu f"ur HPC Anwendungen spezialisierte Rechenkarten, gibt es einen
sehr m"achtigen Weg die jeweiligen Hardwaremerkmale abzufragen. Das kann soweit 
gehen, dass w"ahrend der Laufzeit die Hardwarekonfiguration abgefragt und das 
Problem dynamisch auf die vorhandene Hardware optimiert wird.

An dieser Stelle macht es Sinn sich nochmals vereinfacht die Top-Down-Struktur
von OpenCL (wie bereits in Abbildung \ref{hardware:opencl} gezeigt) vor Augen zu
f"uhren: \texttt{Platform $\rightarrow$ Compute Device $\rightarrow$ Compute
	Unit ($\rightarrow$ Work Group $\rightarrow$ Work Item $\rightarrow$ Work Item
Dimension)}. In dieser Reihenfolge werden auch die Hardwaremerkmale abgefragt.
OpenCL 1.2 stellt dazu folgende Funktionen zur Verf"ugung:

\begin{description}
 \item [clGetPlatformIDs()] gibt eine Liste der vorhandenen Plattformen zur"uck.
 \item [clGetPlatformInfo()] retourniert die Merkmale der aktuellen Plattform. Das heisst,
                            der Herausgeber der Implementation, die imlementierte 
                            OpenCL Version und allf"allig von der Plattform 
                            zus"atzlich unterst"utzte Erweiterungen (Das m"ussen
                            nicht die gleichen sein wie die von den jeweiligen
                            Compute Devices unterst"utzten).
 \item [clGetDeviceIDs()]   Mit der jeweiligen Plattform-ID k"onnen nun die auf der 
                            jeweiligen Plattform verf"ugbaren Compute-Devices abgefragt 
                            werden.
 \item [clGetDeviceInfo()]  Mit den so erhaltenen Device-IDs bekommt man anschliessend 
                            zum abgefragten Compute Device einen ganzen Katalog von
                            Merkmalen zur"uck, von der maximalen Anzahl von Workgroups
                            und Work-Items, "uber die Speicherkapazit"aten bis zur 
                            Clock-Frequenz und dem Hersteller der Hardware. Auf einzelne 
                            dieser Merkmale soll im Folgenden noch eingegangen werden.
\end{description}

\noindent Die genauen Parameter und R"uckgabewerte k"onnen der offiziellen
Dokumentation \cite{crypto:opencl_ref} entnommen werden.

Um das diese Begriffe etwas verst"andlicher zu machen, wird ein kurzes
Code-Beispiel f"ur einen typischen Desktop-Computer mit einer OpenCL f"ahigen
CPU und einer modernen Grafikkarte aufgef"uhrt. Es ist exemplarisch, der
Anschaulichkeit wegen in Pseudocode verfasst und repr"asentiert weder den vollen
Umfang der R"uckgabewerte noch die real ben"otigten Parameter!

\begin{small}
\begin{verbatim}
> clGetPlatformIDs()
0
1

> clGetPlatformInfo(platform=0)
Name:          Intel(R) OpenCL
Vendor:        Intel(R) Corporation
Version:       1.2
Profile:       Full
Extensions:    cl_khr_icd,cl_khr_global_int32_base_atomics,(...)

> clGetPlatformInfo(platform=1)
Name:          NVIDIA(R) OpenCL
Vendor:        NVIDIA Corp. limited
Version:       1.2
Profile:       Full
Extensions:    (...)

> clGetDeviceIDs(platform=0)
0

> clGetDeviceInfo(platform=0,device=0)
General Information:
 - Name:                 Intel(R) Core(TM) i5-3320M CPU @ 2.60GHz
 - Available:            True
 - Vendor (VID):         Intel(R) Corporation (32902)
 - Version:              OpenCL 1.2 (Build 82248)
 - Profile:              full
 - Type:                 CPU 
 - Extensions:           cl_khr_icd,cl_khr_global_int32_base_atomics,(...)
 - Endianess:            Little

Memory and Clocks
 - Clock frequency (max):2600 MHz
 - Compute units:        4
 - Global memory:        7816 MB
 - Local memory:         32768 kB, 2

Kernel properties:
 - Max param. size:      3840 B
 - Max work group size:  8192
 - Max work item dim.:   3
 - Max work item size:   [8192, 8192, 8192]

Datatypes:
 - Flotating point:      Single & Double precision
 - Preferred vector size: 1 (all supported  types)
\end{verbatim}
\end{small}

\vspace{1em}

\noindent Zu einzelnen Punkten aus dem Codebeispiel hier eine kurze Erl"auterung:

\begin{description}
 \item [Version] Implementierte bzw. Unterst"utzte OpenCL Version
 \item [Profile] \texttt{full} oder \texttt{embedded} (in OpenCL 1.2)
 \item [Type]    \texttt{CPU}, \texttt{GPU} oder \texttt{ACCELERATOR}
 \item [Compute Units] Anzahl der physisch vorhandenen Compute Units. Dies ist
                 die Anzahl effektiv parallel ausgef"uhrter Kernel
 \item [Max work group size] Maximale Anzahl Work Items in einer Work Group
 % TODO: Stimmt das "minimal 3"? Sind das nicht maximal 3?
 \item [Max work item dim.] Maximale direkt im Work Item bearbeitbare Dimensionen, minimal 3
 \item [Max work item size] Maximale Anzahl von Work Items in einer Work Group nach
                 Dimensionen (Ist je nach Ger"at unterschiedlich je nach
                 Dimension)
 \item [Preferred vector size] (Nach Datentyp) Vektorgr"osse, die von der Hardware 
                 f"ur den jeweiligen Typ direkt (in einer Instruktion) verarbeitet
                 werden kann.
 
\end{description}


\noindent Dabei gelten anhand der im Code gezeigten Zahlen gem"ass
Spezifikation\cite{crypto:opencl_ref} folgende Regeln:

\begin{itemize}
 \item Eine Work Group wird nur auf einer Compute Unit aufgef"uhrt (1 Work Group = 1 
       Compute Device) 
 \item Die Anzahl der Work-Items pro Work-Group darf insgesamt 8192 nicht "ubersteigen (global work size)
 \item Dabei d"urfen die in ``Max work item size'' angegebenen Werte in der jeweiligen 
       Dimension nicht "uberstiegen werden (local work size $[x,y,z,\ldots]$).
			 Die Summe $x + y + z$ darf dabei aber nicht gr"osser werden als ``Max work group size''.
 \item Die Anzahl effektiv verwendeter Work Item Dimensionen darf im Bereich von 1 bis
       ``Max work item dim.'' liegen.
\end{itemize}


\subparagraph{Maximale Problemgr"osse an einem Beispiel}

Das heisst nun f"ur unser Beispiel folgendes:

\begin{itemize}
 \item asdg
\end{itemize}








- Wo stossen wir an unsere Grenzen?
- Bezug/Referenz auf Einleitung ("Uberlegungen zum Keyspace)

\subsection{Aufteilung von grossen Problemen}

- Was gibt es f"ur L"osungsans"atze?




\section{L"osungsansatz}

Wie haben wir es umgesetzt, und warum?

- Grob-Ansatz, Bezug auf vorherige Section
- Herleitung Wort

\section{Implementationseigenheiten}

(Ev. als Subsection von "L"osungsansatz")
- Limitationen der gew"ahlten L"osung
- Was k"onnte man verbessern?
- ...

\section{Resultate}

- Performancemessungen
- Bedeutung f"ur Umgang mit Passw"ortern

\printbibliography[heading=subbibliography]
\end{refsection}
