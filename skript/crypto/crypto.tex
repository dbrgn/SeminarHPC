\chapter{Knacken von MD5 mit OpenCL}
\rhead{Knacken von MD5 mit OpenCL}
\begin{refsection}

\chapterauthor{Danilo Bargen, Lukas Murer}

\section{Einleitung}

%- Was ist ein Hash-Algorithmus?
%- Was ist MD5?
%- Was ist Brute Force Cracking?
%- "Uberlegungen zum Keyspace
%- Zielsetzung

\subsection{Hashfunktionen}

Hashfunktionen (zu Deutsch \textit{Streuwertfunktionen}) sind in der Informatik
allgegenw"artig. Die Aufgabe einer Hashfunktion ist es, eine beliebig grosse
Eingabemenge auf eine kleine Ausgabemenge mit fester L"ange abzubilden.
Anwendungsgebiete sind beispielsweise die Integrit"atspr"ufung von Daten
(Pr"ufsummen) oder das Verschleiern von Passw"ortern (Passwort-Hashes).

Mathematisch gesehen ist eine Abbildung $h: K \rightarrow S$ eine Hashfunktion,
wenn $|K| \geq |S|$ gilt. Dabei ist $K$ die Menge der Schl"ussel und $S$ die
Menge der m"oglichen Hashwerte.

Eine der einfachsten Hashfunktionen ist die Quersumme, bei welcher die
Ziffernwerte einer Zahl summiert werden.
\[
	q(1337) = 1 + 3 + 3 + 7 = 14
\]
Weitere bekannte Hashfunktionen sind die Divisions-Rest-Methode
(Modulo-Arithmetik), CRC-Pr"ufsummen (Integrit"atspr"ufung) oder der Secure Hash
Algorithm (Kryptologie).

Die Anforderungen an eine ``gute'' Hashfunktion sind Abh"angig vom
Anwendungsbereich. Bei der ISBN-10 ist beispielsweise lediglich eine
Plausibilit"atspr"ufung in Form einer Pr"ufsumme ben"otigt. Bei
Anwendungsf"allen in der Kryptologie (zum Beispiel beim Hashen von Passw"ortern)
sind jedoch viele weitere Kriterien relevant. Nachfolgend werden einige davon
vorgestellt.

\subsection{Eigenschaften von Hashfunktionen}

\subsubsection{Chaos}

Die Ausgabe einer chaotischen Hashfunktion sollte f"ur "ahnliche Eingabewerte
v"ollig unterschiedlich sein. Eine kleine "Anderung am Eingabewert sollte eine
grosse "Anderung im Ausgabewert zur Folge haben.

\subsubsection{Schwierige Umkehrbarkeit}

Eine schwierig umkehrbare Hashfunktion hat zum Ziel die Berechnung des
Funktionswertes m"oglichst zu vereinfachen, aber die Umkehrung dieses Ergebnisses
(errechnen des Ausgangswertes aus der Abbildung) m"oglichst zu erschweren. Anders
gesagt, es soll praktisch nicht m"oglich sein, zu einem gegebenen Hashwert $x$
eine Nachricht $m$ zu finden, f"ur welche $h(m) = x$ gilt.  Funktionen welche
diese Eigenschaften erf"ullen werden auch Einwegfunktionen genannt.

\subsubsection{Surjektivit"at}

Bei einer surjektiven Hashfunktion ist kein Ausgabewert unm"oglich, jeder kann
tats"achlich vorkommen.

\subsubsection{Kollisionsresistenz}
\label{crypto:kollisionsresistenz}

Eine Kollisionsresistente Hashfunktion sollte es erschweren, zwei Eingabewerte
zu finden die den selben Ausgabewert ergeben. Daf"ur sollten die Ausgabewerte
m"oglichst gleichverteilt auftreten.

In der Kryptologie wird zwischen schwacher und starker Kollisionsresistenz
unterschieden:

\begin{itemize}
		\item Schwache Kollisionsresistenz heisst, dass es praktisch nicht m"oglich
			ist, zu einer gegebenen Nachricht $m_0$ eine zweite Nachricht $m_1$ zu finden, f"ur
			welche $h(m_0) = h(m_1)$ gilt.
		\item Starke Kollisionsresistenz heisst, dass es praktisch nicht m"oglich
			ist, zwei Nachrichten $m_0$ und $m_1$ zu finden, f"ur welche $h(m_0) =
			h(m_1)$ gilt.
\end{itemize}

\subsubsection{Effizienz}

Je nach Anwendungsfall m"ochte man effiziente oder ineffiziente Berechnungen
eines Hashwertes erzielen. W"ahrend ersteres logisch erscheint -- man m"ochte den
Algorithmus in Hard- und Software m"oglichst einfach und schnell implementieren
k"onnen -- ist letzteres vor allem f"ur Passwort-Hash-Funktionen relevant. Um zu
verhindern dass ein Angreifer m"oglichst schnell alle m"oglichen Passw"orter
vorberechnet, m"ochte man in dem Fall eine Funktion welche aufw"andig zu berechnen
ist.

\subsection{MD5}

Der MD5 Algorithmus (Message-Digest Algorithm 5) wurde im Jahr 1991 vom
Kryptologen Ronald L. Rivest entwickelt. MD5 erzeugt zu einer beliebigen
Nachricht einen 128-Bit Hashwert.

Unter Unix-basierten Betriebssystemen kann man MD5-Werte ganz einfach auf der
Kommandozeile berechnen:

\begin{verbatim}
$ echo -n "Mathematisches Seminar" | md5sum 
47b2d986d0ae09d6504b9696e9406ca4
\end{verbatim}

Man sieht also, dass der Eingabewert ``Mathematisches Seminar'' auf den
Ausgabewert \texttt{47b2\-d986\-d0ae\-09d6\-504b\-9696\-e940\-6ca4} (in
hexadezimaler Notation) abgebildet wird. Wenn man nun nur ein einzelnes
Zeichen im Eingabestring "andert, sieht die Ausgabe v"ollig anders aus
($\rightarrow$ Chaoseigenschaft):

\begin{verbatim}
$ echo -n "Mathematisches Saminar" | md5sum 
625a5fb1280f153aa06709d70b38dfb8
\end{verbatim}

MD5 war (und ist) weit verbreitet und wurde in der Vergangenheit neben der
Integrit"atspr"ufung auch h"aufig zum Verschleiern von Passw"ortern verwendet. Wie
das funktioniert, l"asst sich einfach an einem Praxisbeispiel demonstrieren:

\begin{enumerate}
		\item Ein Benutzer registriert sich mit Benutzername und Passwort auf einer
			Website. Beide Werte werden an den Webserver "ubertragen.
		\item Der Server berechnet den MD5-Hashwert des Passwortes. Das Passwort wird
			verworfen, nur der Hashwert wird gespeichert.
		\item Der User m"ochte sich zu einem sp"ateren Zeitpunkt wieder einloggen.
			Daf"ur "ubermittelt er erneut das Passwort an den Server.
		\item Der Server berechnet erneut den MD5-Wert des Passwortes und
			vergleicht diesen mit dem zuvor gespeicherten Wert. Stimmen die beiden
			Werte "uberein, wird dem Benutzer Zugang zu den gesch"utzten Inhalten
			gew"ahrt.
\end{enumerate}

An diesem Beispiel erkennt man auch sehr gut, wie wichtig die Einwegeigenschaft
und die Kollisionsresistenz f"ur kryptologische Hashfunktionen ist. Sollte
n"amlich ein Passwort-Hash an die "Offentlichkeit gelangen (beispielsweise durch
einen Hackerangriff, wie sie in den letzten Jahren -- zuletzt bei Adobe -- immer
wieder geschehen sind), sollte es f"ur einen Angreifer mit praktischem Aufwand
nicht m"oglich sein, ausgehend vom Hashwert das urspr"ungliche Passwort zu
errechnen. Ebensowenig sollte es m"oglich sein, ein anderes Passwort zu finden
welches den selben Hashwert ergibt. In beiden F"allen w"are das Benutzerpasswort
dadurch kompromittiert.

MD5 gilt inzwischen als unsicher, weil erfolgreiche Angriffe auf die
Kollisionsresistenz des Algorithmus' gefunden wurden. Bereits im Jahr 2006
gelang es Forschern, MD5-Kollisionen auf einem Pentium 4 Rechner innerhalb einer
Minute zu finden\cite{crypto:stevens2006fast}. Inzwischen sind Kollisionen auf
markt"ublicher Hardware innerhalb weniger Sekunden auffindbar. Der
MD5-Algorithmus ist also h"ochstens schwach kollisionsresistent
(\ref{crypto:kollisionsresistenz}) und sollte f"ur kryptologische Anwendungen
nicht mehr eingesetzt werden.

\subsection{Brute-Force Angriff auf MD5}

W"ahrend Kollisionen f"ur frei gew"ahlte Eingabewerte wie im letzten Abschnitt
beschrieben problemlos berechenbar sind, ist bisher noch kein praktischer
Preimage-Angriff auf MD5 bekannt. Ein Preimage-Angriff bedeutet, dass der
Ausgabewert nicht frei gew"ahlt werden kann, sondern festgelegt ist (ein Angriff
auf die schwache Kollisionsresistenz). Wenn man nun einen Passwort-Hash
zur"uckrechnen will, ist bei einer "uberschaubaren Eingabemenge ein Brute-Force
Angriff effektiver.

Bei einem Brute Force Angriff wird f"ur jeden Werte einer bestimmten
Eingabemenge der Hashwert berechnet und mit dem Zielwert verglichen. In
Pseudocode:

\begin{verbatim}
target = "47b2d986d0ae09d6504b9696e9406ca4"
for word in keyspace:
  if md5(word) == target:
    print(word)
    break
\end{verbatim}

Die Eingabemenge nennt man auch ``Keyspace''. Will man beispielsweise f"ur alle
Passw"orter bestehend aus den Klein- und Grossbuchstaben a-z / A-Z sowie den
Zahlen 0-9 mit einer L"ange von bis zu 6 Zeichen die Hashes berechnen, ergibt
dies "uber 57 Milliarden M"oglichkeiten.
\[
	\sum_{i=1}^{62} 26^i = 57'731'386'986
\]
Hier sieht man auch schon die Schwierigkeit an der Sache, denn der Keyspace
w"achst exponentiell. Bei Erh"ohung der Maximall"ange auf 8 Zeichen sind wir schon
in der Gr"ossenordnung von ~200 Billionen.
\[
	\sum_{i=1}^{62} 26^i = 221'919'451'578'090
\]
Im Rahmen dieser Arbeit beschr"anken wir uns daher auf Passw"orter aus
Kleinbuchstaben mit einer Maximall"ange von 6 Zeichen.

\subsection{Zielsetzung}

Unser Ziel im Rahmen dieser Arbeit war es, durch massiv parallele Berechnung von
MD5-Hashwerten dasjenige Eingabewort zu finden, dessen MD5-Hashwert demjenigen
eines zuvor festgelegten Wertes entspricht. Der Keyspace besteht dabei aus den
Kleinbuchstaben a-z mit einer variablen L"ange von bis zu 6 Zeichen.

Konkret haben wir uns als Ziel gesetzt in m"oglichst kurzer Zeit den MD5-Hash
des Wortes ``monkey'' (Platz 6 auf der Liste der am h"aufigsten verwendeten
Passw"orter 2012 \cite{crypto:splash2012}) zu knacken.

\begin{verbatim}
$ echo -n "monkey" | md5sum
d0763edaa9d9bd2a9516280e9044d885
\end{verbatim}

\section{Umsetzung mit OpenCL}

- Wir haben OpenCL gewählt
- Warum?

\section{Probleme mit grossen Problemen}

- Wo stossen wir an unsere Grenzen?
- Bezug/Referenz auf Einleitung (Überlegungen zum Keyspace)
- Was gibt es f"ur L"osungsans"atze?

\section{L"osungsansatz}

Wie haben wir es umgesetzt, und warum?

- Grob-Ansatz, Bezug auf vorherige Section
- Herleitung Wort

\section{Implementationseigenheiten}

(Ev. als Subsection von "L"osungsansatz")
- Limitationen der gew"ahlten L"osung
- Was k"onnte man verbessern?
- ...

\section{Resultate}

- Performancemessungen
- Bedeutung f"ur Umgang mit Passw"ortern

\printbibliography[heading=subbibliography]
\end{refsection}
